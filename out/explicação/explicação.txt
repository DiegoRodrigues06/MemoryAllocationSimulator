Esse conjunto de c√≥digos implementa um **simulador visual de aloca√ß√£o de mem√≥ria com pagina√ß√£o, escalonamento e simula√ß√£o de E/S** usando Java e Swing.

Aqui est√° um resumo **do que cada parte faz**:

---

### üß± **1. Inicializa√ß√£o da mem√≥ria**

```java
blocosDeMemoria = new ArrayList<>();
for (int i = 0; i < 10; i++) blocosDeMemoria.add(new BlocoDeMemoria(i, 50));
```

* Cria 10 blocos de mem√≥ria de 50KB cada (representam a RAM paginada).
* Cada bloco pode armazenar **1 p√°gina** de 50KB de um processo.

---

### ‚ûï **2. Cria√ß√£o e aloca√ß√£o de processo**

```java
botaoDeAlocacao.addActionListener(e -> {
    ...
    Processo p = new Processo(...);
    alocarPaginas(p);
});
```

* Ao clicar no bot√£o, o programa:

  * L√™ os dados inseridos pelo usu√°rio (nome, tamanho, prioridade, tempo).
  * Cria um processo com **p√°ginas de 50KB**.
  * Tenta alocar as p√°ginas nos blocos de mem√≥ria.
  * Se n√£o houver espa√ßo, ocorre **falha de p√°gina** e a p√°gina vai para o "disco".

---

### üìÑ **3. Fun√ß√£o de aloca√ß√£o com controle de falha de p√°gina**

```java
private void alocarPaginas(Processo p) { ... }
```

* Para cada p√°gina do processo:

  * Tenta achar um bloco livre.
  * Se achar: aloca.
  * Se n√£o: marca a p√°gina como **em disco** e contabiliza a **falha de p√°gina**.

---

### üñºÔ∏è **4. Desenho das p√°ginas em disco**

```java
if (pg.emDisco) { ... }
```

* Desenha as p√°ginas em vermelho no painel (representando que est√£o no disco, n√£o na RAM).

---

### ‚è±Ô∏è **5. Escalonamento por prioridade**

```java
new Thread(() -> {
    while (true) {
        ...
        processos.stream()
            .filter(p -> ...)
            .max(Comparator.comparingInt(p -> p.prioridade))
            .ifPresent(proximo -> { ... });
    }
}).start();
```

* A cada 1 segundo:

  * Escolhe o processo **pronto com maior prioridade**.
  * Executa 1 unidade de tempo.
  * Se terminou: libera os blocos de mem√≥ria.
  * Atualiza o estado (EXECUTANDO, PRONTO, FINALIZADO).

---

### üîÑ **6. Simula√ß√£o de Entrada/Sa√≠da**

```java
botaoSimularES.addActionListener(e -> {
    ...
    p.bloqueado = true;
    Thread.sleep(3000);
    p.bloqueado = false;
});
```

* Ao clicar, um processo aleat√≥rio entra no estado **BLOQUEADO** por 3 segundos.
* Depois volta ao estado **PRONTO**.

---

### üìä **7. Interface atualizada dinamicamente**

* `atualizarStatusMemoria()`: Mostra quanto da RAM est√° ocupada/livre.
* `atualizarEstadoProcessos()`: Lista os processos e seus estados no painel lateral.
* `repaint()`: Redesenha a interface gr√°fica.

---

### üß† **Classes principais**

* `Processo`: Representa o processo com p√°ginas, tempo e prioridade.
* `Pagina`: Representa uma p√°gina do processo (na mem√≥ria ou em disco).
* `BlocoDeMemoria`: Representa um bloco de RAM que pode conter uma p√°gina.
* `EstadoProcesso`: Enum com os estados do processo (NOVO, PRONTO, etc).

---

### ‚úÖ **Resumo final**

Esse simulador:

* Divide os processos em **p√°ginas de 50KB**.
* Aloca p√°ginas na RAM ou manda para o disco (falha de p√°gina).
* Usa **escalonamento por prioridade**, onde o processo com maior prioridade √© executado primeiro.
* Permite simular **opera√ß√µes de E/S**, bloqueando temporariamente processos.
* Atualiza visualmente o estado de mem√≥ria e dos processos.

Se quiser, posso te ajudar a montar um slide ou explica√ß√£o oral disso tamb√©m.
